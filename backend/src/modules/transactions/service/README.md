# A short description of the query service:

The main intent is to have a fluent service, where most of the time creating a new chart/filter does not require any changes in the service code.

# Design details:

Fetching transaction data is a two part process: selection and aggregation.
The response from the service depends entirely on the POST data sent to it. This data must be application/json and in the correct form, required for each selector/aggregator.

The basic structure of a request body looks like this:

```json
{
    "selectors":[
        {"..selector1"},
        {"..selector2"},
        {"..selectorN"}
    ],
    "aggregator":{}
}
```

Selectors are supposed to be fully chainable (as long as mongoose allows) and the selector queue is translated directly into a mongo query

Aggregators use the query generated by the selector queue and return a response (each aggregator may have a different response format). If no aggregator is specified, the `list` aggregator is used and a simple list of transactions is returned.

## Examples

```json
{
  "selectors": [
    {
      "Name": "where",
      "Key": "Amount",
      "Value": {
        "Relationship": "lt",
        "Value": "600"
      }
    }
  ],
  "aggregators": [
    {
      "Name": "list"
    }
  ]
}
```

Return a list of transactions where `Amount` is less than `600`

```json
{
  "selectors": [
    {
      "Name": "where",
      "Key": "Amount",
      "Value": {
        "Relationship": "gt",
        "Value": "0"
      }
    }
  ],
  "aggregator": {
    "Name": "sum",
    "Payload": {
      "distinctColumn": "Category"
    }
  }
}
```

returns a map of categories, where each value is a sum of all the `Amount` fields of transactions with `Amount` greater than `0`. In other words, income sum by category.

WIP
