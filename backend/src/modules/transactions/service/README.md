# A short description of the query service:

The main intent is to have a fluent service, where most of the time creating a new chart/filter does not require any changes in the service code.

# Design details:

Fetching transaction data is a two part process: selection and aggregation.
The response from the service depends entirely on the POST data sent to it. This data must be application/json and in the correct form, required for each selector/aggregator.

The basic structure of a request body looks like this:

```json
{
    "selectors":[
        {"..selector1"},
        {"..selector2"},
        {"..selectorN"}
    ],
    "aggregator":{}
}
```

Selectors are supposed to be fully chainable (as long as mongoose allows) and the selector queue is translated directly into a mongo query

Aggregators use the query generated by the selector queue and return a response (each aggregator may have a different response format). If no aggregator is specified, the `list` aggregator is used and a simple list of transactions is returned.

## Examples

```json
{
  "selectors": [
    {
      "Name": "where",
      "Key": "Amount",
      "Value": {
        "Relationship": "lt",
        "Value": "600"
      }
    }
  ],
  "aggregators": [
    {
      "Name": "list"
    }
  ]
}
```

Return a list of transactions where `Amount` is less than `600`

Refer to the tests for more valid selector examples

## Aggregators

The `sum` aggregator returns a sum of the `Amount`s for all selected transactions,
taking into account a distic column. For example:

```json
{
  "selectors": [
    {
      "Name": "where",
      "Key": "Amount",
      "Value": {
        "Relationship": "gt",
        "Value": "0"
      }
    }
  ],
  "aggregator": {
    "Name": "sum",
    "Payload": {
      "distinctColumn": "Category"
    }
  }
}
```

returns a map of categories, where each value is a sum of all the `Amount` fields of transactions with `Amount` greater than `0`. In other words, income sum by category:

```json
{
  "0": 110,
  "1": 1200,
  "2": 600
}
```

The `balance` aggregator tracks balance over a specified key:

```json
{
  "selectors": [
    {
      "Name": "any"
    }
  ],
  "aggregator": {
    "Name": "balance",
    "Payload": {
      "take": 5,
      "key": "Date"
    }
  }
}
```

here the take parameter specifies how many elements take counting from the last one, (value of 0 returns all)
the balance example query returns something like this:

```json
[
  {
    "key": "2011-10-05T14:48:00.000Z",
    "balance": 1590
  },
  {
    "key": "2019-03-29T16:08:00.000Z",
    "balance": 1600
  },
  {
    "key": "2019-03-29T16:24:00.000Z",
    "balance": 1590
  },
  {
    "key": "2019-03-29T19:11:00.000Z",
    "balance": 1690
  },
  {
    "key": "2019-03-29T19:15:00.000Z",
    "balance": 1680
  }
]
```
